'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _block = require('../models/block');

var _block2 = _interopRequireDefault(_block);

var _inline = require('../models/inline');

var _inline2 = _interopRequireDefault(_inline);

var _mark = require('../models/mark');

var _mark2 = _interopRequireDefault(_mark);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Changes.
 *
 * @type {Object}
 */

var Changes = {};

/**
 * Mix in the changes that just pass through to their at-range equivalents
 * because they don't have any effect on the selection.
 */

var PROXY_TRANSFORMS = ['deleteBackward', 'deleteCharBackward', 'deleteLineBackward', 'deleteWordBackward', 'deleteForward', 'deleteCharForward', 'deleteWordForward', 'deleteLineForward', 'setBlock', 'setInline', 'splitInline', 'unwrapBlock', 'unwrapInline', 'wrapBlock', 'wrapInline'];

PROXY_TRANSFORMS.forEach(function (method) {
  Changes[method] = function (change) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var state = change.state;
    var selection = state.selection;

    var methodAtRange = method + 'AtRange';
    change[methodAtRange].apply(change, [selection].concat(args));
  };
});

/**
 * Add a `mark` to the characters in the current selection.
 *
 * @param {Change} change
 * @param {Mark} mark
 */

Changes.addMark = function (change, mark) {
  mark = _mark2.default.create(mark);
  var state = change.state;
  var document = state.document,
      selection = state.selection;


  if (selection.isExpanded) {
    change.addMarkAtRange(selection, mark);
  } else if (selection.marks) {
    var marks = selection.marks.add(mark);
    var sel = selection.set('marks', marks);
    change.select(sel);
  } else {
    var _marks = document.getActiveMarksAtRange(selection).add(mark);
    var _sel = selection.set('marks', _marks);
    change.select(_sel);
  }
};

/**
 * Delete at the current selection.
 *
 * @param {Change} change
 */

Changes.delete = function (change) {
  var state = change.state;
  var selection = state.selection;

  change.deleteAtRange(selection);

  // Ensure that the selection is collapsed to the start, because in certain
  // cases when deleting across inline nodes, when splitting the inline node the
  // end point of the selection will end up after the split point.
  change.collapseToStart();
};

/**
 * Insert a `block` at the current selection.
 *
 * @param {Change} change
 * @param {String|Object|Block} block
 */

Changes.insertBlock = function (change, block) {
  block = _block2.default.create(block);
  var state = change.state;
  var selection = state.selection;

  change.insertBlockAtRange(selection, block);

  // If the node was successfully inserted, update the selection.
  var node = change.state.document.getNode(block.key);
  if (node) change.collapseToEndOf(node);
};

/**
 * Insert a `fragment` at the current selection.
 *
 * @param {Change} change
 * @param {Document} fragment
 */

Changes.insertFragment = function (change, fragment) {
  if (!fragment.nodes.size) return;

  var state = change.state;
  var _state = state,
      document = _state.document,
      selection = _state.selection;
  var _state2 = state,
      startText = _state2.startText,
      endText = _state2.endText,
      startInline = _state2.startInline;

  var lastText = fragment.getLastText();
  var lastInline = fragment.getClosestInline(lastText.key);
  var keys = document.getTexts().map(function (text) {
    return text.key;
  });
  var isAppending = !startInline || selection.hasEdgeAtStartOf(startText) || selection.hasEdgeAtEndOf(endText);

  change.insertFragmentAtRange(selection, fragment);
  state = change.state;
  document = state.document;

  var newTexts = document.getTexts().filter(function (n) {
    return !keys.includes(n.key);
  });
  var newText = isAppending ? newTexts.last() : newTexts.takeLast(2).first();

  if (newText && lastInline) {
    change.select(selection.collapseToEndOf(newText));
  } else if (newText) {
    change.select(selection.collapseToStartOf(newText).move(lastText.text.length));
  } else {
    change.select(selection.collapseToStart().move(lastText.text.length));
  }
};

/**
 * Insert an `inline` at the current selection.
 *
 * @param {Change} change
 * @param {String|Object|Inline} inline
 */

Changes.insertInline = function (change, inline) {
  inline = _inline2.default.create(inline);
  var state = change.state;
  var selection = state.selection;

  change.insertInlineAtRange(selection, inline);

  // If the node was successfully inserted, update the selection.
  var node = change.state.document.getNode(inline.key);
  if (node) change.collapseToEndOf(node);
};

/**
 * Insert a string of `text` with optional `marks` at the current selection.
 *
 * @param {Change} change
 * @param {String} text
 * @param {Set<Mark>} marks (optional)
 */

Changes.insertText = function (change, text, marks) {
  var state = change.state;
  var document = state.document,
      selection = state.selection;

  marks = marks || selection.marks;
  change.insertTextAtRange(selection, text, marks);

  // If the text was successfully inserted, and the selection had marks on it,
  // unset the selection's marks.
  if (selection.marks && document != change.state.document) {
    change.select({ marks: null });
  }
};

/**
 * Split the block node at the current selection, to optional `depth`.
 *
 * @param {Change} change
 * @param {Number} depth (optional)
 */

Changes.splitBlock = function (change) {
  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var state = change.state;
  var selection = state.selection;

  change.splitBlockAtRange(selection, depth).collapseToEnd();
};

/**
 * Remove a `mark` from the characters in the current selection.
 *
 * @param {Change} change
 * @param {Mark} mark
 */

Changes.removeMark = function (change, mark) {
  mark = _mark2.default.create(mark);
  var state = change.state;
  var document = state.document,
      selection = state.selection;


  if (selection.isExpanded) {
    change.removeMarkAtRange(selection, mark);
  } else if (selection.marks) {
    var marks = selection.marks.remove(mark);
    var sel = selection.set('marks', marks);
    change.select(sel);
  } else {
    var _marks2 = document.getActiveMarksAtRange(selection).remove(mark);
    var _sel2 = selection.set('marks', _marks2);
    change.select(_sel2);
  }
};

/**
 * Add or remove a `mark` from the characters in the current selection,
 * depending on whether it's already there.
 *
 * @param {Change} change
 * @param {Mark} mark
 */

Changes.toggleMark = function (change, mark) {
  mark = _mark2.default.create(mark);
  var state = change.state;

  var exists = state.activeMarks.has(mark);

  if (exists) {
    change.removeMark(mark);
  } else {
    change.addMark(mark);
  }
};

/**
 * Wrap the current selection with prefix/suffix.
 *
 * @param {Change} change
 * @param {String} prefix
 * @param {String} suffix
 */

Changes.wrapText = function (change, prefix) {
  var suffix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : prefix;
  var state = change.state;
  var selection = state.selection;

  change.wrapTextAtRange(selection, prefix, suffix);

  // If the selection was collapsed, it will have moved the start offset too.
  if (selection.isCollapsed) {
    change.moveStart(0 - prefix.length);
  }

  // Adding the suffix will have pushed the end of the selection further on, so
  // we need to move it back to account for this.
  change.moveEnd(0 - suffix.length);

  // There's a chance that the selection points moved "through" each other,
  // resulting in a now-incorrect selection direction.
  if (selection.isForward != change.state.selection.isForward) {
    change.flip();
  }
};

/**
 * Export.
 *
 * @type {Object}
 */

exports.default = Changes;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jaGFuZ2VzL2F0LWN1cnJlbnQtcmFuZ2UuanMiXSwibmFtZXMiOlsiQ2hhbmdlcyIsIlBST1hZX1RSQU5TRk9STVMiLCJmb3JFYWNoIiwibWV0aG9kIiwiY2hhbmdlIiwiYXJncyIsInN0YXRlIiwic2VsZWN0aW9uIiwibWV0aG9kQXRSYW5nZSIsImFkZE1hcmsiLCJtYXJrIiwiY3JlYXRlIiwiZG9jdW1lbnQiLCJpc0V4cGFuZGVkIiwiYWRkTWFya0F0UmFuZ2UiLCJtYXJrcyIsImFkZCIsInNlbCIsInNldCIsInNlbGVjdCIsImdldEFjdGl2ZU1hcmtzQXRSYW5nZSIsImRlbGV0ZSIsImRlbGV0ZUF0UmFuZ2UiLCJjb2xsYXBzZVRvU3RhcnQiLCJpbnNlcnRCbG9jayIsImJsb2NrIiwiaW5zZXJ0QmxvY2tBdFJhbmdlIiwibm9kZSIsImdldE5vZGUiLCJrZXkiLCJjb2xsYXBzZVRvRW5kT2YiLCJpbnNlcnRGcmFnbWVudCIsImZyYWdtZW50Iiwibm9kZXMiLCJzaXplIiwic3RhcnRUZXh0IiwiZW5kVGV4dCIsInN0YXJ0SW5saW5lIiwibGFzdFRleHQiLCJnZXRMYXN0VGV4dCIsImxhc3RJbmxpbmUiLCJnZXRDbG9zZXN0SW5saW5lIiwia2V5cyIsImdldFRleHRzIiwibWFwIiwidGV4dCIsImlzQXBwZW5kaW5nIiwiaGFzRWRnZUF0U3RhcnRPZiIsImhhc0VkZ2VBdEVuZE9mIiwiaW5zZXJ0RnJhZ21lbnRBdFJhbmdlIiwibmV3VGV4dHMiLCJmaWx0ZXIiLCJpbmNsdWRlcyIsIm4iLCJuZXdUZXh0IiwibGFzdCIsInRha2VMYXN0IiwiZmlyc3QiLCJjb2xsYXBzZVRvU3RhcnRPZiIsIm1vdmUiLCJsZW5ndGgiLCJpbnNlcnRJbmxpbmUiLCJpbmxpbmUiLCJpbnNlcnRJbmxpbmVBdFJhbmdlIiwiaW5zZXJ0VGV4dCIsImluc2VydFRleHRBdFJhbmdlIiwic3BsaXRCbG9jayIsImRlcHRoIiwic3BsaXRCbG9ja0F0UmFuZ2UiLCJjb2xsYXBzZVRvRW5kIiwicmVtb3ZlTWFyayIsInJlbW92ZU1hcmtBdFJhbmdlIiwicmVtb3ZlIiwidG9nZ2xlTWFyayIsImV4aXN0cyIsImFjdGl2ZU1hcmtzIiwiaGFzIiwid3JhcFRleHQiLCJwcmVmaXgiLCJzdWZmaXgiLCJ3cmFwVGV4dEF0UmFuZ2UiLCJpc0NvbGxhcHNlZCIsIm1vdmVTdGFydCIsIm1vdmVFbmQiLCJpc0ZvcndhcmQiLCJmbGlwIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBOzs7Ozs7QUFNQSxJQUFNQSxVQUFVLEVBQWhCOztBQUVBOzs7OztBQUtBLElBQU1DLG1CQUFtQixDQUN2QixnQkFEdUIsRUFFdkIsb0JBRnVCLEVBR3ZCLG9CQUh1QixFQUl2QixvQkFKdUIsRUFLdkIsZUFMdUIsRUFNdkIsbUJBTnVCLEVBT3ZCLG1CQVB1QixFQVF2QixtQkFSdUIsRUFTdkIsVUFUdUIsRUFVdkIsV0FWdUIsRUFXdkIsYUFYdUIsRUFZdkIsYUFadUIsRUFhdkIsY0FidUIsRUFjdkIsV0FkdUIsRUFldkIsWUFmdUIsQ0FBekI7O0FBa0JBQSxpQkFBaUJDLE9BQWpCLENBQXlCLFVBQUNDLE1BQUQsRUFBWTtBQUNuQ0gsVUFBUUcsTUFBUixJQUFrQixVQUFDQyxNQUFELEVBQXFCO0FBQUEsc0NBQVRDLElBQVM7QUFBVEEsVUFBUztBQUFBOztBQUFBLFFBQzdCQyxLQUQ2QixHQUNuQkYsTUFEbUIsQ0FDN0JFLEtBRDZCO0FBQUEsUUFFN0JDLFNBRjZCLEdBRWZELEtBRmUsQ0FFN0JDLFNBRjZCOztBQUdyQyxRQUFNQyxnQkFBbUJMLE1BQW5CLFlBQU47QUFDQUMsV0FBT0ksYUFBUCxpQkFBc0JELFNBQXRCLFNBQW9DRixJQUFwQztBQUNELEdBTEQ7QUFNRCxDQVBEOztBQVNBOzs7Ozs7O0FBT0FMLFFBQVFTLE9BQVIsR0FBa0IsVUFBQ0wsTUFBRCxFQUFTTSxJQUFULEVBQWtCO0FBQ2xDQSxTQUFPLGVBQUtDLE1BQUwsQ0FBWUQsSUFBWixDQUFQO0FB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QUFQLENBQWVDLElBQWY7QUFDRDtBQUNGLENBVkQ7O0FBWUE7Ozs7Ozs7O0FBUUFWLFFBQVE2RSxRQUFSLEdBQW1CLFVBQUN6RSxNQUFELEVBQVMwRSxNQUFULEVBQXFDO0FBQUEsTUFBcEJDLE1BQW9CLHVFQUFYRCxNQUFXO0FBQUEsTUFDOUN4RSxLQUQ4QyxHQUNwQ0YsTUFEb0MsQ0FDOUNFLEtBRDhDO0FBQUEsTUFFOUNDLFNBRjhDLEdBRWhDRCxLQUZnQyxDQUU5Q0MsU0FGOEM7O0FBR3RESCxTQUFPNEUsZUFBUCxDQUF1QnpFLFNBQXZCLEVBQWtDdUUsTUFBbEMsRUFBMENDLE1BQTFDOztBQUVBO0FBQ0EsTUFBSXhFLFVBQVUwRSxXQUFkLEVBQTJCO0FBQ3pCN0UsV0FBTzhFLFNBQVAsQ0FBaUIsSUFBSUosT0FBT2xCLE1BQTVCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBeEQsU0FBTytFLE9BQVAsQ0FBZSxJQUFJSixPQUFPbkIsTUFBMUI7O0FBRUE7QUFDQTtBQUNBLE1BQUlyRCxVQUFVNkUsU0FBVixJQUF1QmhGLE9BQU9FLEtBQVAsQ0FBYUMsU0FBYixDQUF1QjZFLFNBQWxELEVBQTZEO0FBQzNEaEYsV0FBT2lGLElBQVA7QUFDRDtBQUNGLENBbkJEOztBQXFCQTs7Ozs7O2tCQU1lckYsTyIsImZpbGUiOiJhdC1jdXJyZW50LXJhbmdlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgQmxvY2sgZnJvbSAnLi4vbW9kZWxzL2Jsb2NrJ1xuaW1wb3J0IElubGluZSBmcm9tICcuLi9tb2RlbHMvaW5saW5lJ1xuaW1wb3J0IE1hcmsgZnJvbSAnLi4vbW9kZWxzL21hcmsnXG5cbi8qKlxuICogQ2hhbmdlcy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbmNvbnN0IENoYW5nZXMgPSB7fVxuXG4vKipcbiAqIE1peCBpbiB0aGUgY2hhbmdlcyB0aGF0IGp1c3QgcGFzcyB0aHJvdWdoIHRvIHRoZWlyIGF0LXJhbmdlIGVxdWl2YWxlbnRzXG4gKiBiZWNhdXNlIHRoZXkgZG9uJ3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBzZWxlY3Rpb24uXG4gKi9cblxuY29uc3QgUFJPWFlfVFJBTlNGT1JNUyA9IFtcbiAgJ2RlbGV0ZUJhY2t3YXJkJyxcbiAgJ2RlbGV0ZUNoYXJCYWNrd2FyZCcsXG4gICdkZWxldGVMaW5lQmFja3dhcmQnLFxuICAnZGVsZXRlV29yZEJhY2t3YXJkJyxcbiAgJ2RlbGV0ZUZvcndhcmQnLFxuICAnZGVsZXRlQ2hhckZvcndhcmQnLFxuICAnZGVsZXRlV29yZEZvcndhcmQnLFxuICAnZGVsZXRlTGluZUZvcndhcmQnLFxuICAnc2V0QmxvY2snLFxuICAnc2V0SW5saW5lJyxcbiAgJ3NwbGl0SW5saW5lJyxcbiAgJ3Vud3JhcEJsb2NrJyxcbiAgJ3Vud3JhcElubGluZScsXG4gICd3cmFwQmxvY2snLFxuICAnd3JhcElubGluZScsXG5dXG5cblBST1hZX1RSQU5TRk9STVMuZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gIENoYW5nZXNbbWV0aG9kXSA9IChjaGFuZ2UsIC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCB7IHN0YXRlIH0gPSBjaGFuZ2VcbiAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGVcbiAgICBjb25zdCBtZXRob2RBdFJhbmdlID0gYCR7bWV0aG9kfUF0UmFuZ2VgXG4gICAgY2hhbmdlW21ldGhvZEF0UmFuZ2VdKHNlbGVjdGlvbiwgLi4uYXJncylcbiAgfVxufSlcblxuLyoqXG4gKiBBZGQgYSBgbWFya2AgdG8gdGhlIGNoYXJhY3RlcnMgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAqIEBwYXJhbSB7TWFya30gbWFya1xuICovXG5cbkNoYW5nZXMuYWRkTWFyayA9IChjaGFuZ2UsIG1hcmspID0+IHtcbiAgbWFyayA9IE1hcmsuY3JlYXRlKG1hcmspXG4gIGNvbnN0IHsgc3RhdGUgfSA9IGNoYW5nZVxuICBjb25zdCB7IGRvY3VtZW50LCBzZWxlY3Rpb24gfSA9IHN0YXRlXG5cbiAgaWYgKHNlbGVjdGlvbi5pc0V4cGFuZGVkKSB7XG4gICAgY2hhbmdlLmFkZE1hcmtBdFJhbmdlKHNlbGVjdGlvbiwgbWFyaylcbiAgfVxuXG4gIGVsc2UgaWYgKHNlbGVjdGlvbi5tYXJrcykge1xuICAgIGNvbnN0IG1hcmtzID0gc2VsZWN0aW9uLm1hcmtzLmFkZChtYXJrKVxuICAgIGNvbnN0IHNlbCA9IHNlbGVjdGlvbi5zZXQoJ21hcmtzJywgbWFya3MpXG4gICAgY2hhbmdlLnNlbGVjdChzZWwpXG4gIH1cblxuICBlbHNlIHtcbiAgICBjb25zdCBtYXJrcyA9IGRvY3VtZW50LmdldEFjdGl2ZU1hcmtzQXRSYW5nZShzZWxlY3Rpb24pLmFkZChtYXJrKVxuICAgIGNvbnN0IHNlbCA9IHNlbGVjdGlvbi5zZXQoJ21hcmtzJywgbWFya3MpXG4gICAgY2hhbmdlLnNlbGVjdChzZWwpXG4gIH1cbn1cblxuLyoqXG4gKiBEZWxldGUgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAqL1xuXG5DaGFuZ2VzLmRlbGV0ZSA9IChjaGFuZ2UpID0+IHtcbiAgY29uc3QgeyBzdGF0ZSB9ID0gY2hhbmdlXG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICBjaGFuZ2UuZGVsZXRlQXRSYW5nZShzZWxlY3Rpb24pXG5cbiAgLy8gRW5zdXJlIHRoYXQgdGhlIHNlbGVjdGlvbiBpcyBjb2xsYXBzZWQgdG8gdGhlIHN0YXJ0LCBiZWNhdXNlIGluIGNlcnRhaW5cbiAgLy8gY2FzZXMgd2hlbiBkZWxldGluZyBhY3Jvc3MgaW5saW5lIG5vZGVzLCB3aGVuIHNwbGl0dGluZyB0aGUgaW5saW5lIG5vZGUgdGhlXG4gIC8vIGVuZCBwb2ludCBvZiB0aGUgc2VsZWN0aW9uIHdpbGwgZW5kIHVwIGFmdGVyIHRoZSBzcGxpdCBwb2ludC5cbiAgY2hhbmdlLmNvbGxhcHNlVG9TdGFydCgpXG59XG5cbi8qKlxuICogSW5zZXJ0IGEgYGJsb2NrYCBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fEJsb2NrfSBibG9ja1xuICovXG5cbkNoYW5nZXMuaW5zZXJ0QmxvY2sgPSAoY2hhbmdlLCBibG9jaykgPT4ge1xuICBibG9jayA9IEJsb2NrLmNyZWF0ZShibG9jaylcbiAgY29uc3QgeyBzdGF0ZSB9ID0gY2hhbmdlXG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICBjaGFuZ2UuaW5zZXJ0QmxvY2tBdFJhbmdlKHNlbGVjdGlvbiwgYmxvY2spXG5cbiAgLy8gSWYgdGhlIG5vZGUgd2FzIHN1Y2Nlc3NmdWxseSBpbnNlcnRlZCwgdXBkYXRlIHRoZSBzZWxlY3Rpb24uXG4gIGNvbnN0IG5vZGUgPSBjaGFuZ2Uuc3RhdGUuZG9jdW1lbnQuZ2V0Tm9kZShibG9jay5rZXkpXG4gIGlmIChub2RlKSBjaGFuZ2UuY29sbGFwc2VUb0VuZE9mKG5vZGUpXG59XG5cbi8qKlxuICogSW5zZXJ0IGEgYGZyYWdtZW50YCBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICogQHBhcmFtIHtEb2N1bWVudH0gZnJhZ21lbnRcbiAqL1xuXG5DaGFuZ2VzLmluc2VydEZyYWdtZW50ID0gKGNoYW5nZSwgZnJhZ21lbnQpID0+IHtcbiAgaWYgKCFmcmFnbWVudC5ub2Rlcy5zaXplKSByZXR1cm5cblxuICBsZXQgeyBzdGF0ZSB9ID0gY2hhbmdlXG4gIGxldCB7IGRvY3VtZW50LCBzZWxlY3Rpb24gfSA9IHN0YXRlXG4gIGNvbnN0IHsgc3RhcnRUZXh0LCBlbmRUZXh0LCBzdGFydElubGluZSB9ID0gc3RhdGVcbiAgY29uc3QgbGFzdFRleHQgPSBmcmFnbWVudC5nZXRMYXN0VGV4dCgpXG4gIGNvbnN0IGxhc3RJbmxpbmUgPSBmcmFnbWVudC5nZXRDbG9zZXN0SW5saW5lKGxhc3RUZXh0LmtleSlcbiAgY29uc3Qga2V5cyA9IGRvY3VtZW50LmdldFRleHRzKCkubWFwKHRleHQgPT4gdGV4dC5rZXkpXG4gIGNvbnN0IGlzQXBwZW5kaW5nID0gKFxuICAgICFzdGFydElubGluZSB8fFxuICAgIHNlbGVjdGlvbi5oYXNFZGdlQXRTdGFydE9mKHN0YXJ0VGV4dCkgfHxcbiAgICBzZWxlY3Rpb24uaGFzRWRnZUF0RW5kT2YoZW5kVGV4dClcbiAgKVxuXG4gIGNoYW5nZS5pbnNlcnRGcmFnbWVudEF0UmFuZ2Uoc2VsZWN0aW9uLCBmcmFnbWVudClcbiAgc3RhdGUgPSBjaGFuZ2Uuc3RhdGVcbiAgZG9jdW1lbnQgPSBzdGF0ZS5kb2N1bWVudFxuXG4gIGNvbnN0IG5ld1RleHRzID0gZG9jdW1lbnQuZ2V0VGV4dHMoKS5maWx0ZXIobiA9PiAha2V5cy5pbmNsdWRlcyhuLmtleSkpXG4gIGNvbnN0IG5ld1RleHQgPSBpc0FwcGVuZGluZyA/IG5ld1RleHRzLmxhc3QoKSA6IG5ld1RleHRzLnRha2VMYXN0KDIpLmZpcnN0KClcblxuICBpZiAobmV3VGV4dCAmJiBsYXN0SW5saW5lKSB7XG4gICAgY2hhbmdlLnNlbGVjdChzZWxlY3Rpb24uY29sbGFwc2VUb0VuZE9mKG5ld1RleHQpKVxuICB9XG5cbiAgZWxzZSBpZiAobmV3VGV4dCkge1xuICAgIGNoYW5nZS5zZWxlY3Qoc2VsZWN0aW9uLmNvbGxhcHNlVG9TdGFydE9mKG5ld1RleHQpLm1vdmUobGFzdFRleHQudGV4dC5sZW5ndGgpKVxuICB9XG5cbiAgZWxzZSB7XG4gICAgY2hhbmdlLnNlbGVjdChzZWxlY3Rpb24uY29sbGFwc2VUb1N0YXJ0KCkubW92ZShsYXN0VGV4dC50ZXh0Lmxlbmd0aCkpXG4gIH1cbn1cblxuLyoqXG4gKiBJbnNlcnQgYW4gYGlubGluZWAgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxJbmxpbmV9IGlubGluZVxuICovXG5cbkNoYW5nZXMuaW5zZXJ0SW5saW5lID0gKGNoYW5nZSwgaW5saW5lKSA9PiB7XG4gIGlubGluZSA9IElubGluZS5jcmVhdGUoaW5saW5lKVxuICBjb25zdCB7IHN0YXRlIH0gPSBjaGFuZ2VcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlXG4gIGNoYW5nZS5pbnNlcnRJbmxpbmVBdFJhbmdlKHNlbGVjdGlvbiwgaW5saW5lKVxuXG4gIC8vIElmIHRoZSBub2RlIHdhcyBzdWNjZXNzZnVsbHkgaW5zZXJ0ZWQsIHVwZGF0ZSB0aGUgc2VsZWN0aW9uLlxuICBjb25zdCBub2RlID0gY2hhbmdlLnN0YXRlLmRvY3VtZW50LmdldE5vZGUoaW5saW5lLmtleSlcbiAgaWYgKG5vZGUpIGNoYW5nZS5jb2xsYXBzZVRvRW5kT2Yobm9kZSlcbn1cblxuLyoqXG4gKiBJbnNlcnQgYSBzdHJpbmcgb2YgYHRleHRgIHdpdGggb3B0aW9uYWwgYG1hcmtzYCBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7U2V0PE1hcms+fSBtYXJrcyAob3B0aW9uYWwpXG4gKi9cblxuQ2hhbmdlcy5pbnNlcnRUZXh0ID0gKGNoYW5nZSwgdGV4dCwgbWFya3MpID0+IHtcbiAgY29uc3QgeyBzdGF0ZSB9ID0gY2hhbmdlXG4gIGNvbnN0IHsgZG9jdW1lbnQsIHNlbGVjdGlvbiB9ID0gc3RhdGVcbiAgbWFya3MgPSBtYXJrcyB8fCBzZWxlY3Rpb24ubWFya3NcbiAgY2hhbmdlLmluc2VydFRleHRBdFJhbmdlKHNlbGVjdGlvbiwgdGV4dCwgbWFya3MpXG5cbiAgLy8gSWYgdGhlIHRleHQgd2FzIHN1Y2Nlc3NmdWxseSBpbnNlcnRlZCwgYW5kIHRoZSBzZWxlY3Rpb24gaGFkIG1hcmtzIG9uIGl0LFxuICAvLyB1bnNldCB0aGUgc2VsZWN0aW9uJ3MgbWFya3MuXG4gIGlmIChzZWxlY3Rpb24ubWFya3MgJiYgZG9jdW1lbnQgIT0gY2hhbmdlLnN0YXRlLmRvY3VtZW50KSB7XG4gICAgY2hhbmdlLnNlbGVjdCh7IG1hcmtzOiBudWxsIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBTcGxpdCB0aGUgYmxvY2sgbm9kZSBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24sIHRvIG9wdGlvbmFsIGBkZXB0aGAuXG4gKlxuICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICogQHBhcmFtIHtOdW1iZXJ9IGRlcHRoIChvcHRpb25hbClcbiAqL1xuXG5DaGFuZ2VzLnNwbGl0QmxvY2sgPSAoY2hhbmdlLCBkZXB0aCA9IDEpID0+IHtcbiAgY29uc3QgeyBzdGF0ZSB9ID0gY2hhbmdlXG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICBjaGFuZ2VcbiAgICAuc3BsaXRCbG9ja0F0UmFuZ2Uoc2VsZWN0aW9uLCBkZXB0aClcbiAgICAuY29sbGFwc2VUb0VuZCgpXG59XG5cbi8qKlxuICogUmVtb3ZlIGEgYG1hcmtgIGZyb20gdGhlIGNoYXJhY3RlcnMgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAqIEBwYXJhbSB7TWFya30gbWFya1xuICovXG5cbkNoYW5nZXMucmVtb3ZlTWFyayA9IChjaGFuZ2UsIG1hcmspID0+IHtcbiAgbWFyayA9IE1hcmsuY3JlYXRlKG1hcmspXG4gIGNvbnN0IHsgc3RhdGUgfSA9IGNoYW5nZVxuICBjb25zdCB7IGRvY3VtZW50LCBzZWxlY3Rpb24gfSA9IHN0YXRlXG5cbiAgaWYgKHNlbGVjdGlvbi5pc0V4cGFuZGVkKSB7XG4gICAgY2hhbmdlLnJlbW92ZU1hcmtBdFJhbmdlKHNlbGVjdGlvbiwgbWFyaylcbiAgfVxuXG4gIGVsc2UgaWYgKHNlbGVjdGlvbi5tYXJrcykge1xuICAgIGNvbnN0IG1hcmtzID0gc2VsZWN0aW9uLm1hcmtzLnJlbW92ZShtYXJrKVxuICAgIGNvbnN0IHNlbCA9IHNlbGVjdGlvbi5zZXQoJ21hcmtzJywgbWFya3MpXG4gICAgY2hhbmdlLnNlbGVjdChzZWwpXG4gIH1cblxuICBlbHNlIHtcbiAgICBjb25zdCBtYXJrcyA9IGRvY3VtZW50LmdldEFjdGl2ZU1hcmtzQXRSYW5nZShzZWxlY3Rpb24pLnJlbW92ZShtYXJrKVxuICAgIGNvbnN0IHNlbCA9IHNlbGVjdGlvbi5zZXQoJ21hcmtzJywgbWFya3MpXG4gICAgY2hhbmdlLnNlbGVjdChzZWwpXG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgb3IgcmVtb3ZlIGEgYG1hcmtgIGZyb20gdGhlIGNoYXJhY3RlcnMgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLFxuICogZGVwZW5kaW5nIG9uIHdoZXRoZXIgaXQncyBhbHJlYWR5IHRoZXJlLlxuICpcbiAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAqIEBwYXJhbSB7TWFya30gbWFya1xuICovXG5cbkNoYW5nZXMudG9nZ2xlTWFyayA9IChjaGFuZ2UsIG1hcmspID0+IHtcbiAgbWFyayA9IE1hcmsuY3JlYXRlKG1hcmspXG4gIGNvbnN0IHsgc3RhdGUgfSA9IGNoYW5nZVxuICBjb25zdCBleGlzdHMgPSBzdGF0ZS5hY3RpdmVNYXJrcy5oYXMobWFyaylcblxuICBpZiAoZXhpc3RzKSB7XG4gICAgY2hhbmdlLnJlbW92ZU1hcmsobWFyaylcbiAgfSBlbHNlIHtcbiAgICBjaGFuZ2UuYWRkTWFyayhtYXJrKVxuICB9XG59XG5cbi8qKlxuICogV3JhcCB0aGUgY3VycmVudCBzZWxlY3Rpb24gd2l0aCBwcmVmaXgvc3VmZml4LlxuICpcbiAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdWZmaXhcbiAqL1xuXG5DaGFuZ2VzLndyYXBUZXh0ID0gKGNoYW5nZSwgcHJlZml4LCBzdWZmaXggPSBwcmVmaXgpID0+IHtcbiAgY29uc3QgeyBzdGF0ZSB9ID0gY2hhbmdlXG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICBjaGFuZ2Uud3JhcFRleHRBdFJhbmdlKHNlbGVjdGlvbiwgcHJlZml4LCBzdWZmaXgpXG5cbiAgLy8gSWYgdGhlIHNlbGVjdGlvbiB3YXMgY29sbGFwc2VkLCBpdCB3aWxsIGhhdmUgbW92ZWQgdGhlIHN0YXJ0IG9mZnNldCB0b28uXG4gIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHtcbiAgICBjaGFuZ2UubW92ZVN0YXJ0KDAgLSBwcmVmaXgubGVuZ3RoKVxuICB9XG5cbiAgLy8gQWRkaW5nIHRoZSBzdWZmaXggd2lsbCBoYXZlIHB1c2hlZCB0aGUgZW5kIG9mIHRoZSBzZWxlY3Rpb24gZnVydGhlciBvbiwgc29cbiAgLy8gd2UgbmVlZCB0byBtb3ZlIGl0IGJhY2sgdG8gYWNjb3VudCBmb3IgdGhpcy5cbiAgY2hhbmdlLm1vdmVFbmQoMCAtIHN1ZmZpeC5sZW5ndGgpXG5cbiAgLy8gVGhlcmUncyBhIGNoYW5jZSB0aGF0IHRoZSBzZWxlY3Rpb24gcG9pbnRzIG1vdmVkIFwidGhyb3VnaFwiIGVhY2ggb3RoZXIsXG4gIC8vIHJlc3VsdGluZyBpbiBhIG5vdy1pbmNvcnJlY3Qgc2VsZWN0aW9uIGRpcmVjdGlvbi5cbiAgaWYgKHNlbGVjdGlvbi5pc0ZvcndhcmQgIT0gY2hhbmdlLnN0YXRlLnNlbGVjdGlvbi5pc0ZvcndhcmQpIHtcbiAgICBjaGFuZ2UuZmxpcCgpXG4gIH1cbn1cblxuLyoqXG4gKiBFeHBvcnQuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBDaGFuZ2VzXG4iXX0=